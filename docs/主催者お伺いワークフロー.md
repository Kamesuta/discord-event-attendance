# 主催者お伺いワークフロー機能　実装計画

## 概要
イベント主催者を順番に依頼していく「主催者お伺いワークフロー」機能を追加する。

## 機能要件

### お伺い計画フロー
1. 週一でイベント管理チャンネルにパネルを出して管理者に催促
2. パネルで依頼順を決める（1週間分のイベントのうち、主催者が決まっていないものについて）
3. 3人程度自動ピックアップ（最近参加、ローテーション考慮）
4. 依頼メッセージや公募オプション設定可能

### 主催者お伺いフロー  
1. DMで三択ボタン付きお伺いメッセージ
2. 一日以内に返事がないか断りの場合次へ
3. DMチャットの双方向転送
4. 進捗状況の管理
5. 並行公募オプション

## 技術調査結果

### 現在のシステム構造
- **イベント管理**: EventManager.ts を中心としたPrismaベースのシステム
- **権限システム**: checkCommandPermission.ts で `/event` コマンドの権限チェック
- **コマンド構造**: event_creator_command/ でイベント管理者用機能を提供
- **メッセージシステム**: MessageUpdater/MessageUpdateManager で自動更新
- **設定管理**: config.toml でサーバー設定
- **スケジューリング**: node-schedule使用

### 既存機能の活用ポイント
- イベント主催者設定機能は既に実装済み
- Webhook連携メッセージシステムが利用可能
- 権限チェック機能が利用可能
- 参加履歴データ（UserStat）が利用可能

## データベース設計

### 新規テーブル追加

#### 1. HostRequest（お伺いリクエスト）
```prisma
model HostRequest {
  id        Int      @id @default(autoincrement())
  eventId   Int      
  priority  Int      // 依頼順（1番手、2番手...）
  userId    Int      
  status    String   // "pending", "accepted", "declined", "expired"
  message   String?  @db.VarChar(1000) // カスタム依頼メッセージ
  dmMessageId String? // DMのメッセージID
  expiresAt DateTime // 期限
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId]) // 同じイベントの同じユーザーへの重複依頼を防ぐ
}
```

#### 2. HostWorkflow（お伺いワークフロー）
```prisma
model HostWorkflow {
  id                Int      @id @default(autoincrement())
  eventId           Int      @unique
  currentPriority   Int      @default(1) // 現在依頼中の順番
  status            String   // "planning", "requesting", "completed", "cancelled"
  allowPublicApply  Boolean  @default(false) // 並行公募フラグ
  publicApplyMessageId String? // 公募メッセージID
  customMessage     String?  @db.VarChar(1000) // カスタム依頼メッセージ
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  event             Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
}
```

### DM会話転送のDiscordメッセージベース管理

#### DMConversationテーブルを削除
従来のDMConversationテーブルは削除し、代わりにDiscordメッセージの機能を活用してDB管理を不要にします。

#### Discordメッセージベースの管理方法

1. **メッセージEmbedを使った情報埋め込み**
   ```typescript
   // DMメッセージのEmbed footerに情報を記載
   embed.setFooter({
     text: `HostRequest:${hostRequestId} | Event:${eventId} | User:${userId}`
   });
   ```

2. **スレッドを使った会話管理**
   - イベント管理チャンネルでDM転送用のスレッドを作成
   - スレッド名: `[DM転送] ${eventName} - ${userName}`
   - 各DMメッセージをスレッド内に転送

3. **返信機能を使った関連付け**
   ```typescript
   // 管理者からの返信をDMに転送する際、元メッセージを参照
   await dmChannel.send({
     content: `**管理者より:**\n${adminMessage}`,
     reply: { messageReference: originalDmMessageId }
   });
   ```

4. **メッセージIDベースの追跡**
   ```typescript
   // DMメッセージIDと管理チャンネルメッセージIDをHostRequestに保存
   // 複数メッセージの場合は、最初のメッセージIDのみ保存し、
   // スレッド内で時系列順に管理
   ```

## 設定追加

### config.toml に追加項目
```toml
# 主催者お伺いワークフロー設定
host_request_channel_id = "123456789" # イベント管理チャンネル
host_request_proposal_channel_id = "123456789" # イベント案チャンネル（公募用）
host_request_timeout_hours = 24 # お伺いのタイムアウト時間（時間）
host_request_schedule_day = 0 # 週何曜日にパネルを出すか (0=日曜)
host_request_schedule_time = "21:00" # 何時にパネルを出すか
```

### Config型の拡張
```typescript
// src/utils/config.ts に追加
export interface Config {
  // ... 既存設定 ...
  
  /** 主催者お伺い管理チャンネルID */
  host_request_channel_id: string;
  
  /** イベント案チャンネルID（公募用） */
  host_request_proposal_channel_id: string;
  
  /** お伺いのタイムアウト時間（時間） */
  host_request_timeout_hours: number;
  
  /** 週何曜日にパネルを出すか (0=日曜) */
  host_request_schedule_day: number;
  
  /** 何時にパネルを出すか */
  host_request_schedule_time: string;
}
```

## 実装ファイル構成

### 1. コマンド群
```
src/commands/event_host_command/
├── commands.ts                    # コマンドエクスポート
├── EventHostCommand.ts            # メインコマンドグループ
├── EventHostPlanCommand.ts        # /event_host plan - 計画作成
├── EventHostStatusCommand.ts      # /event_host status - 進捗確認
├── EventHostStartCommand.ts       # /event_host start - ワークフロー開始
└── EventHostCancelCommand.ts      # /event_host cancel - キャンセル
```

### 2. アクション群
```
src/commands/action/event_host_command/
├── PlanSetupButtonAction.ts       # 計画設定ボタン
├── PlanConfirmButtonAction.ts     # 計画確定ボタン
├── PlanEditModalAction.ts         # 計画編集モーダル
├── UserPickButtonAction.ts        # ユーザー選択ボタン
├── PublicApplyButtonAction.ts     # 公募応募ボタン
├── HostAcceptButtonAction.ts      # 受諾ボタン（DM）
├── HostDeclineButtonAction.ts     # 断るボタン（DM）
└── HostAlternateButtonAction.ts   # 別日提案ボタン（DM）
```

### 3. コア機能
```
src/event/
├── HostRequestManager.ts          # お伺い管理の中核クラス
├── HostWorkflowManager.ts         # ワークフロー管理
├── DMRelayManager.ts              # DM転送管理（メッセージベース）
└── HostPickupAlgorithm.ts         # 主催者ピックアップアルゴリズム
```

### 4. メッセージ管理
```
src/message_updaters/
└── HostRequestMessageUpdater.ts   # 主催者お伺いメッセージ更新
```

## DMRelayManager の実装詳細

### メッセージベースDM転送の仕組み

```typescript
export class DMRelayManager {
  /**
   * DMメッセージを管理チャンネルに転送
   */
  async relayDMToChannel(
    dmMessage: Message,
    hostRequestId: number,
    eventName: string,
    userName: string
  ): Promise<void> {
    const channel = await this.getManagementChannel();
    
    // スレッドを取得または作成
    const thread = await this.getOrCreateDMThread(channel, eventName, userName);
    
    // メッセージを転送（元のDMメッセージIDを埋め込み）
    await thread.send({
      embeds: [{
        description: dmMessage.content,
        author: {
          name: userName,
          iconURL: dmMessage.author.displayAvatarURL()
        },
        footer: {
          text: `DM:${dmMessage.id} | HostRequest:${hostRequestId}`
        },
        timestamp: dmMessage.createdAt
      }]
    });
  }

  /**
   * 管理チャンネルからDMに転送
   */
  async relayChannelToDM(
    channelMessage: Message,
    targetUserId: string
  ): Promise<void> {
    // footerからHostRequestIDを抽出
    const hostRequestId = this.extractHostRequestId(channelMessage);
    const hostRequest = await this.getHostRequest(hostRequestId);
    
    // DMチャンネルを取得
    const user = await client.users.fetch(targetUserId);
    const dmChannel = await user.createDM();
    
    // 管理者名とメッセージを転送
    await dmChannel.send({
      embeds: [{
        description: channelMessage.content,
        author: {
          name: `管理者: ${channelMessage.author.displayName}`,
          iconURL: channelMessage.author.displayAvatarURL()
        },
        color: 0x3498db
      }]
    });
  }

  /**
   * DMスレッドを取得または作成
   */
  private async getOrCreateDMThread(
    channel: TextChannel,
    eventName: string,
    userName: string
  ): Promise<ThreadChannel> {
    const threadName = `[DM転送] ${eventName} - ${userName}`;
    
    // 既存スレッドを検索
    const existingThread = channel.threads.cache.find(
      thread => thread.name === threadName
    );
    
    if (existingThread) {
      return existingThread;
    }
    
    // 新規スレッド作成
    return await channel.threads.create({
      name: threadName,
      autoArchiveDuration: ThreadAutoArchiveDuration.OneWeek
    });
  }
}
```

## 実装フェーズ

### フェーズ1: 基盤実装（1-2週間）
1. **データベース設計**
   - Prismaスキーマ拡張（DMConversationテーブルは除外）
   - マイグレーション作成・実行

2. **設定システム拡張**
   - config.toml拡張
   - Config型更新
   - バリデーション追加

3. **コア機能クラス**
   - HostRequestManager.ts実装
   - HostWorkflowManager.ts実装
   - 基本CRUD操作

### フェーズ2: お伺い計画フロー（2-3週間）
1. **コマンド実装**
   - EventHostCommand.ts（メインコマンドグループ）
   - EventHostPlanCommand.ts（計画作成）
   - EventHostStatusCommand.ts（進捗確認）

2. **ピックアップアルゴリズム**
   - HostPickupAlgorithm.ts実装
   - 参加履歴分析
   - ローテーション機能
   - イベントタイプ別分析

3. **UI実装**
   - 計画作成パネル
   - ユーザー選択UI
   - 設定調整UI

### フェーズ3: お伺いフロー（2-3週間）
1. **DMメッセージシステム**
   - EventHostStartCommand.ts
   - DM送信機能
   - 三択ボタン実装

2. **応答処理**
   - HostAcceptButtonAction.ts
   - HostDeclineButtonAction.ts
   - HostAlternateButtonAction.ts
   - 次の候補への自動切り替え

3. **タイムアウト処理**
   - node-schedule統合
   - 期限切れ自動処理

### フェーズ4: DM転送・公募機能（1-2週間）
1. **DM転送システム**
   - DMRelayManager.ts実装（メッセージベース）
   - メッセージハンドラー拡張
   - スレッドベース会話管理

2. **公募機能**
   - PublicApplyButtonAction.ts
   - 応募処理
   - 権限チェック統合

### フェーズ5: スケジューリング・統合（1週間）
1. **自動スケジューリング**
   - 週次パネル表示
   - updateSchedules統合

2. **テスト・バグフィックス**
   - 統合テスト
   - エラーハンドリング強化

## 技術課題と対策

### 1. DMメッセージング
**課題**: 現在のシステムはサーバー内メッセージ中心
**対策**: 
- client.users.send()を使用
- DMチャンネル管理機能追加
- エラーハンドリング強化（DM無効ユーザー対応）

### 2. メッセージベースDM転送
**課題**: DBなしでのメッセージ関連付け
**対策**: 
- Embedのfooterに必要情報を埋め込み
- スレッドで会話を整理
- メッセージIDベースの追跡
- 正規表現でのメタデータ抽出

### 3. 状態管理
**課題**: 複数の非同期プロセスの状態管理
**対策**: 
- データベースベースの状態管理
- 楽観的ロック
- 重複処理防止

## セキュリティ考慮事項

1. **権限チェック強化**
   - 各アクションでの権限再確認
   - DM送信前の権限チェック

2. **入力値検証**
   - SQLインジェクション対策
   - XSS対策（メッセージ内容）

3. **レート制限**
   - DM送信頻度制限
   - 同一ユーザーへの重複依頼防止

## まとめ

この実装計画では、DMConversationテーブルを廃止し、Discordのメッセージ機能（Embed、スレッド、返信）を活用してDM転送を管理します。これにより：

- **データベース管理の簡素化**: 追加テーブルが不要
- **Discordネイティブな体験**: スレッドで自然な会話管理
- **メンテナンス性の向上**: メッセージベースで直感的な管理

実装期間: 約6-9週間
リスクレベル: 中
技術難易度: 中