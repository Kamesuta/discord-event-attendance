# 主催者お伺いワークフロー設計ドキュメント

## 概要

Discord イベントの主催者を決めるための自動化されたワークフローシステム。候補者への段階的なお伺いと、並行公募機能を提供します。

## 機能要件

### お伺い計画フロー
1. 週一でイベント管理チャンネルにパネルを出して管理者に催促
2. パネルで依頼順を決める（1週間分のイベントのうち、主催者が決まっていないものについて）
3. 3人程度自動ピックアップ（最近参加、ローテーション考慮）
4. 依頼メッセージや公募オプション設定可能

### 主催者お伺いフロー  
1. DMで三択ボタン付きお伺いメッセージ
2. 一日以内に返事がないか断りの場合次へ
3. DMチャットの双方向転送
4. 進捗状況の管理
5. 並行公募オプション

## データベース設計

### 修正されたスキーマ

```prisma
enum HostRequestStatus {
  WAITING   // 0: 順番待ち（まだDM送信していない）
  PENDING   // 1: 依頼中（DM送信済み、返答待ち）
  ACCEPTED  // 2: 承認
  DECLINED  // 3: 承認されなかった（拒否・期限切れ・他者承認等）
}

model HostWorkflow {
  id                   Int      @id @default(autoincrement())
  eventId              Int      @unique
  allowPublicApply     Boolean  @default(false)
  publicApplyMessageId String?  // 公募メッセージID
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // リレーション
  event    Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  requests HostRequest[] // このワークフローに属するリクエスト
}

model HostRequest {
  id          Int               @id @default(autoincrement())
  workflowId  Int               // ワークフローID（外部キー）
  priority    Int               // 依頼順（1番手、2番手、3番手...）
  userId      Int               // 依頼対象ユーザーID
  status      HostRequestStatus @default(WAITING)
  message     String?           @db.VarChar(1000) // 個別カスタム依頼メッセージ
  dmMessageId String?           // DMのメッセージID
  expiresAt   DateTime          // 期限
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  // リレーション
  workflow HostWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([workflowId, userId]) // 同じワークフローの同じユーザーへの重複依頼を防ぐ
  @@unique([workflowId, priority]) // 同じワークフローで同じ順番の重複を防ぐ
}
```

## 設計変更の理由

### 1. リレーション強化
- **変更前**: `HostRequest`と`HostWorkflow`が`eventId`を通してのみ関連
- **変更後**: `HostRequest.workflowId`で直接的な親子関係を確立
- **メリット**: データ整合性向上、効率的なクエリ実行

### 2. 冗長性除去
- **変更前**: `HostRequest.eventId`が存在、`HostWorkflow.status`でワークフロー状態管理
- **変更後**: `HostRequest.eventId`を削除、ワークフロー状態は`HostRequest`から導出
- **メリット**: データの一貫性保証、正規化の実現、状態不整合の防止

### 3. メッセージ管理統一
- **変更前**: `HostWorkflow.customMessage`（全体用）+ `HostRequest.message`（個別用）
- **変更後**: `HostRequest.message`のみ（人ごとに個別設定）
- **メリット**: より柔軟な個別対応、設定の分散防止

### 4. ステータス管理改善
- **変更前**: `currentPriority`フィールドで進行状況管理
- **変更後**: `HostRequest.status`による状態ベース管理
- **メリット**: より直感的、複雑な状態管理ロジック不要

### 5. 型安全性向上
- **変更前**: 文字列ステータス（"pending", "completed"等）
- **変更後**: Prisma Enum（`HostRequestStatus`）
- **メリット**: タイポ防止、IDE補完サポート、型チェック

## ワークフロー状態遷移

### ワークフロー全体の状態（HostRequestから導出）
```
全WAITING → 一部PENDING → 一つACCEPTED（完了）
  (計画中)      (依頼中)       (確定)
      ↓           ↓
   全DECLINED（キャンセル）
```

### HostRequestStatus
```
WAITING → PENDING → ACCEPTED
             ↓    
         DECLINED → 次の WAITING が PENDING に
         (拒否・期限切れ・他者承認等)
```

## 業務フロー

### 1. 計画フェーズ（PLANNING）
1. 管理者が候補者を設定
2. 各候補者の優先順位（1番手、2番手、3番手）を決定
3. 個別メッセージを設定（オプション）
4. 並行公募設定

### 2. 依頼フェーズ（REQUESTING）
1. **初期状態**: 全候補者が`WAITING`状態
2. **1番手開始**: 1番手を`WAITING`→`PENDING`に変更、DM送信
3. **タイムアウト設定**: `expiresAt`を設定
4. **返答待ち**: `PENDING`状態で待機

### 3. 返答処理
- **承認時**: `status = ACCEPTED` → 他の候補者を`DECLINED` → ワークフロー完了
- **拒否時**: `status = DECLINED` → 次の優先度の`WAITING`を`PENDING`に
- **期限切れ**: `status = DECLINED` → 次の優先度の`WAITING`を`PENDING`に
- **全候補者終了**: 全員が`DECLINED`の場合、ワークフローキャンセル

### 4. 並行公募
- `allowPublicApply = true`の場合
- 候補者へのDMと並行して公募チャンネルにメッセージ投稿
- 早い者勝ち方式

## データベースクエリ例

### ワークフローと関連リクエスト取得
```typescript
const workflowWithRequests = await prisma.hostWorkflow.findUnique({
  where: { eventId },
  include: {
    requests: {
      include: { user: true },
      orderBy: { priority: 'asc' }
    },
    event: true
  }
});
```

### 現在依頼中のリクエスト取得
```typescript
const currentRequest = await prisma.hostRequest.findFirst({
  where: {
    workflowId,
    status: HostRequestStatus.PENDING
  },
  include: { user: true }
});
```

### 次の候補者取得
```typescript
const nextCandidate = await prisma.hostRequest.findFirst({
  where: {
    workflowId,
    status: HostRequestStatus.WAITING
  },
  include: { user: true },
  orderBy: { priority: 'asc' }
});
```

### 候補者一覧（優先順位順）
```typescript
const candidates = await prisma.hostRequest.findMany({
  where: { workflowId },
  include: { user: true },
  orderBy: { priority: 'asc' }
});
```

## マイグレーション計画

### ステップ1: Enumの追加
```sql
-- HostRequestStatus Enum  
CREATE TYPE "HostRequestStatus" AS ENUM ('WAITING', 'PENDING', 'ACCEPTED', 'DECLINED');
```

### ステップ2: スキーマ変更
```sql
-- HostWorkflow テーブル変更
ALTER TABLE "HostWorkflow" 
  DROP COLUMN "currentPriority",
  DROP COLUMN "customMessage",
  DROP COLUMN "status";

-- HostRequest テーブル変更
ALTER TABLE "HostRequest"
  ADD COLUMN "workflowId" INTEGER NOT NULL,
  DROP COLUMN "eventId",
  ALTER COLUMN "status" TYPE "HostRequestStatus" USING 'WAITING'::"HostRequestStatus";

-- 外部キー制約追加
ALTER TABLE "HostRequest"
  ADD CONSTRAINT "HostRequest_workflowId_fkey" 
  FOREIGN KEY ("workflowId") REFERENCES "HostWorkflow"("id") ON DELETE CASCADE;

-- ユニーク制約変更
ALTER TABLE "HostRequest"
  DROP CONSTRAINT "HostRequest_eventId_userId_key",
  ADD CONSTRAINT "HostRequest_workflowId_userId_key" UNIQUE ("workflowId", "userId"),
  ADD CONSTRAINT "HostRequest_workflowId_priority_key" UNIQUE ("workflowId", "priority");
```

### ステップ3: データ移行
```typescript
// 既存データの移行ロジック
const workflows = await prisma.hostWorkflow.findMany({
  include: { event: true }
});

for (const workflow of workflows) {
  // 関連するHostRequestを更新
  await prisma.hostRequest.updateMany({
    where: { eventId: workflow.eventId },
    data: { workflowId: workflow.id }
  });
}
```

## 追加検討事項と修正点

### パフォーマンス改善
- `HostRequest.workflowId`にインデックス追加
- `HostRequest.status`にインデックス追加（現在依頼中検索の高速化）

### 拡張性
- 将来的な候補者数増加に対応（priority制限なし）
- カスタム期限設定（リクエストごと）
- 通知設定の個別化

### 監査・ログ
- ワークフロー変更履歴の記録
- リクエスト応答時間の追跡
- 成功率の分析機能

## ワークフロー状態の導出方法

新しい設計では、ワークフロー全体の状態は`HostRequest`の状態から動的に判定します：

```typescript
function getWorkflowStatus(requests: HostRequest[]): 'planning' | 'requesting' | 'completed' | 'cancelled' {
  if (requests.length === 0) return 'planning';
  if (requests.some(r => r.status === 'ACCEPTED')) return 'completed';
  if (requests.some(r => r.status === 'PENDING')) return 'requesting';
  if (requests.every(r => r.status === 'DECLINED')) return 'cancelled';
  return 'planning'; // 全てWAITING
}
```

### 現在のコードへの影響
1. **HostWorkflowManager.ts**: `eventId`ベースから`workflowId`ベースのクエリに変更、状態導出ロジック追加
2. **HostRequestManager.ts**: `createRequest`メソッドの引数を`workflowId`に変更
3. **EventHostPlanCommand.ts**: `_formatWorkflowInfo`メソッドでワークフロー状態を動的取得
4. **PlanConfirmButtonAction.ts**: HostRequest作成時の`workflowId`指定

### 現在の実装との矛盾点
- 現在のコードでは`hostRequestManager.createRequest`が`eventId`を引数にしているが、新スキーマでは`workflowId`が必要
- `HostRequestWithRelations`型の定義を更新する必要がある
- `HostWorkflowWithRelations`型から`status`フィールドを削除
- 既存のクエリをすべて`workflowId`ベースに変更する必要がある

### DM会話転送のDiscordメッセージベース管理

#### DMConversationテーブルを削除
従来のDMConversationテーブルは削除し、代わりにDiscordメッセージの機能を活用してDB管理を不要にします。

#### Discordメッセージベースの管理方法

1. **メッセージEmbedを使った情報埋め込み**
   ```typescript
   // DMメッセージのEmbed footerに情報を記載
   embed.setFooter({
     text: `HostRequest:${hostRequestId} | Event:${eventId} | User:${userId}`
   });
   ```

2. **スレッドを使った会話管理**
   - イベント管理チャンネルでDM転送用のスレッドを作成
   - スレッド名: `[DM転送] ${eventName} - ${userName}`
   - 各DMメッセージをスレッド内に転送

3. **返信機能を使った関連付け**
   ```typescript
   // 管理者からの返信をDMに転送する際、元メッセージを参照
   await dmChannel.send({
     content: `**管理者より:**\n${adminMessage}`,
     reply: { messageReference: originalDmMessageId }
   });
   ```

4. **メッセージIDベースの追跡**
   ```typescript
   // DMメッセージIDと管理チャンネルメッセージIDをHostRequestに保存
   // 複数メッセージの場合は、最初のメッセージIDのみ保存し、
   // スレッド内で時系列順に管理
   ```

## 設定追加

### config.toml に追加項目
```toml
# 主催者お伺いワークフロー設定
host_request_channel_id = "123456789" # イベント管理チャンネル
host_request_proposal_channel_id = "123456789" # イベント案チャンネル（公募用）
host_request_timeout_hours = 24 # お伺いのタイムアウト時間（時間）
host_request_schedule_day = 0 # 週何曜日にパネルを出すか (0=日曜)
host_request_schedule_time = "21:00" # 何時にパネルを出すか
```

### Config型の拡張
```typescript
// src/utils/config.ts に追加
export interface Config {
  // ... 既存設定 ...
  
  /** 主催者お伺い管理チャンネルID */
  host_request_channel_id: string;
  
  /** イベント案チャンネルID（公募用） */
  host_request_proposal_channel_id: string;
  
  /** お伺いのタイムアウト時間（時間） */
  host_request_timeout_hours: number;
  
  /** 週何曜日にパネルを出すか (0=日曜) */
  host_request_schedule_day: number;
  
  /** 何時にパネルを出すか */
  host_request_schedule_time: string;
}
```

## 実装ファイル構成

### 1. コマンド群
```
src/commands/event_host_command/
├── commands.ts                    # コマンドエクスポート
├── EventHostCommand.ts            # メインコマンドグループ
├── EventHostPlanCommand.ts        # /event_host plan - 計画作成
├── EventHostStatusCommand.ts      # /event_host status - 進捗確認
├── EventHostStartCommand.ts       # /event_host start - ワークフロー開始
└── EventHostCancelCommand.ts      # /event_host cancel - キャンセル
```

### 2. アクション群
```
src/commands/action/event_host_command/
├── PlanSetupButtonAction.ts       # 計画設定ボタン
├── PlanConfirmButtonAction.ts     # 計画確定ボタン
├── PlanEditModalAction.ts         # 計画編集モーダル
├── UserPickButtonAction.ts        # ユーザー選択ボタン
├── PublicApplyButtonAction.ts     # 公募応募ボタン
├── HostAcceptButtonAction.ts      # 受諾ボタン（DM）
├── HostDeclineButtonAction.ts     # 断るボタン（DM）
└── HostAlternateButtonAction.ts   # 別日提案ボタン（DM）
```

### 3. コア機能
```
src/event/
├── HostRequestManager.ts          # お伺い管理の中核クラス
├── HostWorkflowManager.ts         # ワークフロー管理
├── DMRelayManager.ts              # DM転送管理（メッセージベース）
└── HostPickupAlgorithm.ts         # 主催者ピックアップアルゴリズム
```

### 4. メッセージ管理
```
src/message_updaters/
└── HostRequestMessageUpdater.ts   # 主催者お伺いメッセージ更新
```

## DMRelayManager の実装詳細

### メッセージベースDM転送の仕組み

```typescript
export class DMRelayManager {
  /**
   * DMメッセージを管理チャンネルに転送
   */
  async relayDMToChannel(
    dmMessage: Message,
    hostRequestId: number,
    eventName: string,
    userName: string
  ): Promise<void> {
    const channel = await this.getManagementChannel();
    
    // スレッドを取得または作成
    const thread = await this.getOrCreateDMThread(channel, eventName, userName);
    
    // メッセージを転送（元のDMメッセージIDを埋め込み）
    await thread.send({
      embeds: [{
        description: dmMessage.content,
        author: {
          name: userName,
          iconURL: dmMessage.author.displayAvatarURL()
        },
        footer: {
          text: `DM:${dmMessage.id} | HostRequest:${hostRequestId}`
        },
        timestamp: dmMessage.createdAt
      }]
    });
  }

  /**
   * 管理チャンネルからDMに転送
   */
  async relayChannelToDM(
    channelMessage: Message,
    targetUserId: string
  ): Promise<void> {
    // footerからHostRequestIDを抽出
    const hostRequestId = this.extractHostRequestId(channelMessage);
    const hostRequest = await this.getHostRequest(hostRequestId);
    
    // DMチャンネルを取得
    const user = await client.users.fetch(targetUserId);
    const dmChannel = await user.createDM();
    
    // 管理者名とメッセージを転送
    await dmChannel.send({
      embeds: [{
        description: channelMessage.content,
        author: {
          name: `管理者: ${channelMessage.author.displayName}`,
          iconURL: channelMessage.author.displayAvatarURL()
        },
        color: 0x3498db
      }]
    });
  }

  /**
   * DMスレッドを取得または作成
   */
  private async getOrCreateDMThread(
    channel: TextChannel,
    eventName: string,
    userName: string
  ): Promise<ThreadChannel> {
    const threadName = `[DM転送] ${eventName} - ${userName}`;
    
    // 既存スレッドを検索
    const existingThread = channel.threads.cache.find(
      thread => thread.name === threadName
    );
    
    if (existingThread) {
      return existingThread;
    }
    
    // 新規スレッド作成
    return await channel.threads.create({
      name: threadName,
      autoArchiveDuration: ThreadAutoArchiveDuration.OneWeek
    });
  }
}
```

## 実装フェーズ

### フェーズ1: 基盤実装（1-2週間）
1. **データベース設計**
   - Prismaスキーマ拡張（DMConversationテーブルは除外）
   - マイグレーション作成・実行

2. **設定システム拡張**
   - config.toml拡張
   - Config型更新
   - バリデーション追加

3. **コア機能クラス**
   - HostRequestManager.ts実装
   - HostWorkflowManager.ts実装
   - 基本CRUD操作

### フェーズ2: お伺い計画フロー（2-3週間）
1. **コマンド実装**
   - EventHostCommand.ts（メインコマンドグループ）
   - EventHostPlanCommand.ts（計画作成）
   - EventHostStatusCommand.ts（進捗確認）

2. **ピックアップアルゴリズム**
   - HostPickupAlgorithm.ts実装
   - 参加履歴分析
   - ローテーション機能
   - イベントタイプ別分析

3. **UI実装**
   - 計画作成パネル
   - ユーザー選択UI
   - 設定調整UI

### フェーズ3: お伺いフロー（2-3週間）
1. **DMメッセージシステム**
   - EventHostStartCommand.ts
   - DM送信機能
   - 三択ボタン実装

2. **応答処理**
   - HostAcceptButtonAction.ts
   - HostDeclineButtonAction.ts
   - HostAlternateButtonAction.ts
   - 次の候補への自動切り替え

3. **タイムアウト処理**
   - node-schedule統合
   - 期限切れ自動処理

### フェーズ4: DM転送・公募機能（1-2週間）
1. **DM転送システム**
   - DMRelayManager.ts実装（メッセージベース）
   - メッセージハンドラー拡張
   - スレッドベース会話管理

2. **公募機能**
   - PublicApplyButtonAction.ts
   - 応募処理
   - 権限チェック統合

### フェーズ5: スケジューリング・統合（1週間）
1. **自動スケジューリング**
   - 週次パネル表示
   - updateSchedules統合

2. **テスト・バグフィックス**
   - 統合テスト
   - エラーハンドリング強化

## 技術課題と対策

### 1. DMメッセージング
**課題**: 現在のシステムはサーバー内メッセージ中心
**対策**: 
- client.users.send()を使用
- DMチャンネル管理機能追加
- エラーハンドリング強化（DM無効ユーザー対応）

### 2. メッセージベースDM転送
**課題**: DBなしでのメッセージ関連付け
**対策**: 
- Embedのfooterに必要情報を埋め込み
- スレッドで会話を整理
- メッセージIDベースの追跡
- 正規表現でのメタデータ抽出

### 3. 状態管理
**課題**: 複数の非同期プロセスの状態管理
**対策**: 
- データベースベースの状態管理
- 楽観的ロック
- 重複処理防止

## セキュリティ考慮事項

1. **権限チェック強化**
   - 各アクションでの権限再確認
   - DM送信前の権限チェック

2. **入力値検証**
   - SQLインジェクション対策
   - XSS対策（メッセージ内容）

3. **レート制限**
   - DM送信頻度制限
   - 同一ユーザーへの重複依頼防止

## まとめ

この実装計画では、DMConversationテーブルを廃止し、Discordのメッセージ機能（Embed、スレッド、返信）を活用してDM転送を管理します。これにより：

- **データベース管理の簡素化**: 追加テーブルが不要
- **Discordネイティブな体験**: スレッドで自然な会話管理
- **メンテナンス性の向上**: メッセージベースで直感的な管理

実装期間: 約6-9週間
リスクレベル: 中
技術難易度: 中