# リファクタリング計画

## 1. 目的

コードベースが複雑化してきたため、保守性・テスト容易性・拡張性を向上させるためのリファクタリングを実施する。
特に、`src/event/` フォルダと `src/event_handler.ts` (700行) の複雑さを解消し、責務を明確に分離する。

## 2. 現状の問題点

### 2.1. `event_handler.ts` の肥大化 (700行)

**問題:**
- イベントライフサイクル管理、スケジューリング、ロール同期、通知など、複数の責務が混在
- テストが困難
- 変更時の影響範囲が大きい

**責務の混在例:**
- イベント作成・開始・終了処理
- node-scheduleによるスケジューリング
- ロール付与・剥奪
- リマインダー送信
- データベース更新

### 2.2. `src/event/` フォルダの構造的問題

**問題:**
- データアクセス層、ビジネスロジック層、プレゼンテーション層が混在
- ファイルの抽象度がバラバラ（EventManager: 387行 vs splitStrings: 24行）
- Singletonパターンによりテストが困難
- エラーハンドリング戦略が統一されていない
- 小文字から始まるクラス名を消したい。→ クラス化したい。

**具体例:**
- `EventManager.ts`: クエリロジック + ビジネスロジック + Discord API呼び出し
- `game.ts`: データ取得 + XP計算 + Discord Embed生成
- `UserManager.ts`, `MessageEditor.ts`: Singleton + 状態保持

### 2.3. レイヤー間の責務の曖昧さ

```
現状:
┌──────────────────────────────────────┐
│  event_handler.ts (God Object)       │
│  - ライフサイクル + スケジュール +   │
│    ロール管理 + 通知 + DB操作        │
└──────────────┬───────────────────────┘
               │
     ┌─────────┴──────────┐
     │                    │
┌────▼─────┐      ┌──────▼───────┐
│ Commands │      │  Event Folder │
│          │      │  (混在した責務) │
└──────────┘      └──────────────┘
```

## 3. リファクタリング方針

### 3.1. レイヤードアーキテクチャの導入

以下の3層構造に分離する:

```
理想形:
┌─────────────────────────────────────────┐
│  Presentation Layer (Commands/Handlers) │ ← ユーザー入力・Discord UI
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│  Service Layer (Business Logic)         │ ← ビジネスルール・ワークフロー
│  - EventLifecycleService                │
│  - EventSchedulerService                │
│  - GameService                          │
│  - RoleManagementService                │
│  - NotificationService                  │
└────────────┬────────────────────────────┘
             │
prisma直接操作 ← データベース操作

※データへのアクセスは無駄にRepository層を挟まず、直接Prisma Clientを利用
3個所所以上で同じクエリを書く場合のみRepository層を導入

**調査結果: 以下のパターンがRepository化候補**
1. ✅ eventIncludeHost - すでに定数化済み (src/event/EventManager.ts:16-20)
   - 15ファイル、30箇所以上で使用される最頻出パターン
   - include: { host: true, preparer: true }

2. ⚠️ gameResultInclude - 部分的に定数化済み (src/event/game.ts:35-46)
   - 5ファイルで使用、一部で手動再定義されている
   - include: { event: { include: { host: true } }, users: { include: { user: true } } }

3. ❌ userStatIncludeUser - 定数化推奨
   - 4ファイルで同じパターンが繰り返されている
   - include: { user: true }

4. ❌ hostSelectPatterns - 定数化推奨
   - 6ファイルで3つのバリエーションが使用されている
   - select: { host: { select: { userId, username, displayName, memberName } } }

→ Repository層は導入せず、既存の定数化パターン(eventIncludeHost等)を拡充する方針
→ event/ フォルダ全体を domain/ にリネームし、サブフォルダで整理する
```

### 3.2. フォルダ構成の再編成

```
src/
├── commands/              (既存: そのまま)
├── services/              (新規: ビジネスロジック層)
│   ├── EventLifecycleService.ts
│   ├── EventSchedulerService.ts
│   ├── GameService.ts
│   ├── RoleManagementService.ts
│   ├── NotificationService.ts
│   └── AttendanceService.ts
├── domain/               (event/ をリネーム)
│   ├── services/         (EventManager等を配置)
│   │   ├── EventManager.ts
│   │   └── UserManager.ts
│   ├── queries/          (Prismaクエリパターン定数)
│   │   ├── eventQueries.ts     (eventIncludeHost等)
│   │   ├── gameQueries.ts      (gameResultInclude等)
│   │   └── userQueries.ts      (userStatIncludeUser等)
│   ├── formatters/       (プレゼンテーション層)
│   │   ├── EventFormatter.ts
│   │   └── GameResultFormatter.ts
│   └── models/           (型定義 - 必要に応じて)
│       └── types.ts
├── utils/                (既存 + event/ のユーティリティを移動)
│   ├── permissions/
│   │   └── checkCommandPermission.ts  (event/から移動)
│   ├── parsers/
│   │   ├── periodParser.ts            (event/から移動)
│   │   ├── searchParser.ts            (event/から移動)
│   │   └── dateParser.ts              (既存)
│   ├── discord/
│   │   ├── getWebhook.ts              (event/から移動)
│   │   ├── MessageEditor.ts           (event/から移動)
│   │   └── EditableInteraction.ts     (event/から移動)
│   └── string/
│       └── splitStrings.ts            (event/から移動)
├── message_updaters/     (既存: そのまま)
└── event_handler.ts      (分割対象)
```

## 4. 段階的リファクタリング計画

### Phase 1: 準備 (影響範囲の調査)

**目的:** リファクタリングの影響範囲を把握し、安全に進めるための下準備

**タスク:**
1. 依存関係マップの作成
   - `event_handler.ts` から呼ばれているすべての関数をリストアップ
   - `src/event/` の各ファイルがどこから参照されているか調査
2. テストケースの確認
   - 既存のテストがあるか確認
   - ない場合、リファクタリング前に基本的な統合テストを追加
3. 型定義の整理
   - `EventWithHost` などの型定義を `domain/models/` に移動する準備

**完了条件:**
- 依存関係図の作成完了
- 最低限の統合テストの実装（主要なコマンド実行が成功することを確認）

### Phase 2: Utilsの分離 (低リスク)

**目的:** 影響範囲が小さい純粋関数を先に移動し、フォルダ構成を整理

**タスク:**
1. `src/utils/` 配下にサブフォルダ作成
   ```
   utils/
   ├── permissions/
   ├── parsers/
   ├── discord/
   └── string/
   ```
2. 以下のファイルを event/ から移動 & import文を修正
   - `splitStrings.ts` → `utils/string/`
   - `searchParser.ts`, `periodParser.ts` → `utils/parsers/`
   - `checkCommandPermission.ts` → `utils/permissions/`
   - `getWebhook.ts`, `MessageEditor.ts`, `EditableInteraction.ts` → `utils/discord/`
3. 各ファイルのimportパスを一括置換
   ```typescript
   // Before
   import { splitStrings } from '@/event/splitStrings'
   // After
   import { splitStrings } from '@/utils/string/splitStrings'
   ```

**完了条件:**
- すべてのimportエラーが解消
- ビルドが成功
- 既存のテストが通る

### Phase 4: Service層の作成 (中リスク)

**目的:** ビジネスロジックをService層に集約し、責務を明確化

**タスク:**
1. `src/services/` フォルダ作成
2. `GameService.ts` の実装
   ```typescript
   // src/services/GameService.ts
   import { prisma } from '@/utils/prisma'
   import type { GameResultData, Award } from '@/domain/models/GameResult'

   export class GameService {
     /**
      * ゲーム結果を計算する
      * (game.ts の showGameResults から抽出)
      */
     async calculateGameResults(eventId: number): Promise<GameResultData> {
       const event = await prisma.event.findUnique({
         where: { id: eventId },
         include: {
           voiceLogs: {
             include: { user: true },
           },
           attendance: {
             include: { user: true },
           },
         },
       })

       if (!event) {
         throw new Error(`Event not found: ${eventId}`)
       }

       // XP計算ロジック (game.ts から移動)
       const awards = this.calculateAwards(event)

       return {
         event,
         awards,
         totalXP: awards.reduce((sum, a) => sum + a.xp, 0),
       }
     }

     /**
      * XP計算ロジック
      */
     private calculateAwards(event: EventWithVoiceLogsAndAttendance): Award[] {
       // 既存のXP計算ロジックをここに移動
       // ...
     }
   }

   export const gameService = new GameService()
   ```

3. `AttendanceService.ts` の実装
   ```typescript
   // src/services/AttendanceService.ts
   import { prisma } from '@/utils/prisma'

   export class AttendanceService {
     /**
      * 出席時間を計算・更新する
      * (attendance_time.ts から抽出)
      */
     async updateAttendanceTime(eventId: number): Promise<void> {
       const attendanceTime = await this.calculateAttendanceTime(eventId)

       await prisma.attendance.updateMany({
         where: { eventId },
         data: { attendanceTime },
       })
     }

     private async calculateAttendanceTime(eventId: number) {
       // 既存の calculateAttendanceTime ロジックを移動
       // VoiceLogから出席時間を計算
       // ...
     }
   }

   export const attendanceService = new AttendanceService()
   ```

4. `RoleManagementService.ts` の実装
   ```typescript
   // src/services/RoleManagementService.ts
   import type { GuildMember, Role } from 'discord.js'

   export class RoleManagementService {
     /**
      * ロールを同期する
      * (roleManager.ts から抽出)
      */
     async syncRole(member: GuildMember, role: Role, shouldHaveRole: boolean): Promise<void> {
       // 既存の syncRole ロジックを移動
       // ...
     }

     async syncRoleByCondition(
       member: GuildMember,
       role: Role,
       condition: (member: GuildMember) => Promise<boolean>
     ): Promise<void> {
       // 既存の syncRoleByCondition ロジックを移動
       // ...
     }
   }

   export const roleManagementService = new RoleManagementService()
   ```

**完了条件:**
- 各Serviceクラスの実装完了
- ビジネスロジックのテスト追加

### Phase 5: event_handler.ts の分割 (高リスク)

**目的:** 700行のGod Objectを責務ごとに分割

**タスク:**
1. `EventLifecycleService.ts` の実装
   ```typescript
   // src/services/EventLifecycleService.ts
   import type { GuildScheduledEvent } from 'discord.js'
   import { prisma } from '@/utils/prisma'
   import { attendanceService } from './AttendanceService'
   import { roleManagementService } from './RoleManagementService'

   export class EventLifecycleService {
     /**
      * イベント作成時の処理
      */
     async handleEventCreate(discordEvent: GuildScheduledEvent): Promise<void> {
       // event_handler.ts の onScheduledEventCreate から抽出
       // prisma.event.create(...) でイベント作成
       // ...
     }

     /**
      * イベント開始時の処理
      */
     async handleEventStart(discordEvent: GuildScheduledEvent): Promise<void> {
       // event_handler.ts の onScheduledEventStart から抽出
       // prisma.event.update(...) でステータス更新
       // ...
     }

     /**
      * イベント終了時の処理
      */
     async handleEventEnd(discordEvent: GuildScheduledEvent): Promise<void> {
       // event_handler.ts の onScheduledEventEnd から抽出
       // 出席時間計算
       await attendanceService.updateAttendanceTime(eventId)
       // ロール同期
       await roleManagementService.syncEventRoles(eventId)
       // ...
     }

     /**
      * イベント削除時の処理
      */
     async handleEventDelete(discordEvent: GuildScheduledEvent): Promise<void> {
       // event_handler.ts の onScheduledEventDelete から抽出
       // prisma.event.delete(...) でイベント削除
       // ...
     }
   }

   export const eventLifecycleService = new EventLifecycleService()
   ```

2. `EventSchedulerService.ts` の実装
   ```typescript
   // src/services/EventSchedulerService.ts
   import * as schedule from 'node-schedule'
   import { prisma } from '@/utils/prisma'
   import { notificationService } from './NotificationService'

   export class EventSchedulerService {
     private jobs = new Map<string, schedule.Job>()

     /**
      * イベントのリマインダーをスケジュール
      */
     async scheduleReminders(eventId: number): Promise<void> {
       // event_handler.ts のスケジューリングロジックを抽出
       const event = await prisma.event.findUnique({
         where: { id: eventId },
       })
       if (!event) return

       // 1時間前リマインダー
       const reminderTime = new Date(event.scheduledStartTime)
       reminderTime.setHours(reminderTime.getHours() - 1)

       const job = schedule.scheduleJob(reminderTime, async () => {
         await notificationService.sendReminder(eventId)
       })

       this.jobs.set(`reminder-${eventId}`, job)
     }

     /**
      * スケジュールされたジョブをキャンセル
      */
     cancelScheduledJobs(eventId: number): void {
       const jobKey = `reminder-${eventId}`
       const job = this.jobs.get(jobKey)
       if (job) {
         job.cancel()
         this.jobs.delete(jobKey)
       }
     }
   }

   export const eventSchedulerService = new EventSchedulerService()
   ```

3. `NotificationService.ts` の実装
   ```typescript
   // src/services/NotificationService.ts
   import { client } from '@/utils/client'
   import { prisma } from '@/utils/prisma'
   import { config } from '@/config'

   export class NotificationService {
     /**
      * リマインダーを送信
      */
     async sendReminder(eventId: number): Promise<void> {
       const event = await prisma.event.findUnique({
         where: { id: eventId },
         include: { host: true },
       })
       // リマインダー送信ロジック
       // ...
     }

     /**
      * イベント開始通知を送信
      */
     async sendStartNotification(eventId: number): Promise<void> {
       // 開始通知ロジック
       // ...
     }
   }

   export const notificationService = new NotificationService()
   ```

4. `event_handler.ts` を簡潔に書き換え
   ```typescript
   // src/event_handler.ts (リファクタリング後)
   import { Events, type Client } from 'discord.js'
   import { eventLifecycleService } from '@/services/EventLifecycleService'
   import { logger } from '@/utils/logger'

   export function registerEventHandlers(client: Client) {
     // イベント作成
     client.on(Events.GuildScheduledEventCreate, async (discordEvent) => {
       try {
         await eventLifecycleService.handleEventCreate(discordEvent)
       } catch (error) {
         logger.error('Failed to handle event create:', error)
       }
     })

     // イベント開始
     client.on(Events.GuildScheduledEventUpdate, async (oldEvent, newEvent) => {
       try {
         if (oldEvent.status !== newEvent.status && newEvent.isActive()) {
           await eventLifecycleService.handleEventStart(newEvent)
         }
       } catch (error) {
         logger.error('Failed to handle event start:', error)
       }
     })

     // イベント終了
     client.on(Events.GuildScheduledEventUpdate, async (oldEvent, newEvent) => {
       try {
         if (oldEvent.status !== newEvent.status && newEvent.isCompleted()) {
           await eventLifecycleService.handleEventEnd(newEvent)
         }
       } catch (error) {
         logger.error('Failed to handle event end:', error)
       }
     })

     // イベント削除
     client.on(Events.GuildScheduledEventDelete, async (discordEvent) => {
       try {
         await eventLifecycleService.handleEventDelete(discordEvent)
       } catch (error) {
         logger.error('Failed to handle event delete:', error)
       }
     })
   }
   ```

**完了条件:**
- `event_handler.ts` が100行未満に削減
- 各Serviceが単一の責務を持つ
- すべてのイベントハンドリングが正常動作

### Phase 6: Domain層の整理 (低リスク)

**目的:** 型定義とフォーマッターを整理し、プレゼンテーション層を分離

**タスク:**
1. `src/domain/` フォルダ作成
   ```
   domain/
   ├── models/
   │   ├── Event.ts
   │   ├── User.ts
   │   ├── GameResult.ts
   │   └── Attendance.ts
   └── formatters/
       ├── EventFormatter.ts
       ├── GameResultFormatter.ts
       └── AttendanceFormatter.ts
   ```

2. 型定義を `domain/models/` に移動
   ```typescript
   // src/domain/models/Event.ts
   import type { Event, User, Prisma } from '@prisma/client'

   export type EventWithHost = Prisma.EventGetPayload<{
     include: { host: true }
   }>

   export type EventWithAttendance = Prisma.EventGetPayload<{
     include: { attendance: { include: { user: true } } }
   }>
   ```

3. `GameResultFormatter.ts` の実装
   ```typescript
   // src/domain/formatters/GameResultFormatter.ts
   import type { EmbedBuilder } from 'discord.js'
   import type { GameResultData } from '@/domain/models/GameResult'

   export class GameResultFormatter {
     /**
      * ゲーム結果のEmbedを作成
      * (game.ts の makeGameResultEmbed から抽出)
      */
     formatAsEmbed(data: GameResultData): EmbedBuilder {
       // 既存のEmbed生成ロジックを移動
       // ...
     }

     /**
      * ゲーム結果のテキストを作成
      */
     formatAsText(data: GameResultData): string {
       // テキスト形式のフォーマット
       // ...
     }
   }

   export const gameResultFormatter = new GameResultFormatter()
   ```

4. `game.ts` を削除し、ロジックを分散
   - データ取得 → `GameService`
   - Embed生成 → `GameResultFormatter`

5. `event/` フォルダを `domain/` にリネーム

6. Prismaクエリパターン定数を `domain/queries/` に整理
   ```typescript
   // src/domain/queries/eventQueries.ts
   import { Prisma } from '@prisma/client'

   // EventManager.ts から移動
   export const eventIncludeHost = {
     include: { host: true, preparer: true }
   } satisfies Prisma.EventFindUniqueArgs
   export type EventWithHost = Prisma.EventGetPayload<typeof eventIncludeHost>
   ```

   ```typescript
   // src/domain/queries/gameQueries.ts
   export const gameResultInclude = {
     include: {
       event: { include: { host: true } },
       users: { include: { user: true } }
     }
   } satisfies Prisma.GameResultFindUniqueArgs
   ```

   ```typescript
   // src/domain/queries/userQueries.ts
   export const userStatIncludeUser = {
     include: { user: true }
   } satisfies Prisma.UserStatFindManyArgs
   ```

7. EventManager.ts → `domain/services/EventManager.ts` に移動し、eventIncludeHost を `domain/queries/eventQueries` からimport
8. UserManager.ts → `domain/services/UserManager.ts` に移動
9. 各ファイルで手動定義されている userStatIncludeUser を `domain/queries/userQueries` からimportに置き換え

**完了条件:**
- `src/event/` フォルダが `src/domain/` にリネーム済み
- EventManager.ts, UserManager.ts が `domain/services/` に配置
- クエリパターン定数が `domain/queries/` に集約
- 3箇所以上使われているクエリは全て定数化済み
